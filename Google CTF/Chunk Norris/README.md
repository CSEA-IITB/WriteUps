# Chunk Norris

Here we have yet another RSA challenge in which we have to factor N exploiting the prime generation function provided.

Clearly, it may seem like usual prime generation but a close inspection reveals that it is just a prime generated by appending the outputs of PRNG together.

Hence if we are able to find the `s` i.e. the initial seed of PRNG, we can generate all other blocks and hence the prime!

Alas, challenge creator could not think beyond 64 bits of entropy!

```python
def gen_prime(bits):
  s = random.getrandbits(chunk_size)

  while True:
    s |= 0xc000000000000001
    p = 0
    for _ in range(bits // chunk_size):
      p = (p << chunk_size) + s
      s = a * s % 2**chunk_size
    if gmpy2.is_prime(p):
      return p
 ```

 The prime numbers `p` & `q` are 1024 bits in length, and suppose we have `S = s | 0xc000000000000001`, then it is guaranteed that `S` would be 64 bits long, since its last, first & second bits are set.
 Consider `p` formed from `S1` and `q` formed from `S2`, then `p` would have the following structure -

`--S1--|--(a*S1)--|--(a^2*S1)--|...|--(a^15*S1)--`, where all the products are modulo `2^64` and hence, each block is 64 bits long - meaning `1024/64 = 16` blocks!  
Suppose `z = a^(-1) modulo (2^64)`, then we could rewrite the above structure as -  
`--(z^15*F1)--|..|--(z*F1)--|--(F1)--`, where `F1 = (a^15*S1) modulo (2^64)`, and similarly we have `F2`.

Or, we can write `p = summation for i in [0,15], {F1*z^i % 2^64} * 2^(64*i)`.

Thus, we have `n = p*q = summation for i, j in [0,15] [{F1*z^i % 2^64} * {F2*z^i % 2^64}] * 2^(64*(i+j))`!

Quite non-intuitive right! Consider `F = F1 * F2`, then `F` would be 128 bits long.

Consider the ending blocks of `n` -  

```
..|---64 bits---|---64 bits---|---64 bits---|
  |--(F1*z) x F2+(F2*z) x F1--|
                |----------F1 x F2----------|
```

where in the above diagram `*` denotes multiplication modulo `(2^64)` and `x` denotes the usual multiplication.

We observe the following -
```
Last 64 bits of n = Last 64 bits of (F1 x F2) = M &
Next 64 bits of n = [Upper 64 bits of (F1 x F2) + E] modulo (2^64) = N,

where E = lower 64 bits of (F1*z) x F2 + (F2*z) x F1  
        = [(F1*z) x F2 + (F2*z) x F1] % (2^64)  
        = [{(F1*z) x F2}%(2^64) + {(F2*z) x F1}%(2^64)] % (2^64)  
        = [{z*F1*F2} + {z*F1*F2}] % (2^64)  
        = (2*z * F1 * F2) % (2^64)
        = ((2*z) * {(F1 x F2)%(2^64)}) % (2^64)  
        = (2*z*M) % (2^64)
```

Thus, we can obtain both lower 64 and upper 64 bits of `F`, and 
since `F1` & `F2` are each 64 bits long, `F = F1 x F2` is 128 bits long, `F` is obtainable.

In our case, we have `M = n % (2^64) = 176717718511119129 = 0x273d3d4255f6b19` & `N = (n // (2^64)) % (2^64) = 12243943457175785960 = 0xa9eb39b3feee51e8`, giving us the bits of `F` as -

`lo = M = 0x0273d3d4255f6b19 (64 bits = 8 bytes)` & `hi = (N-2*z*M) % (2^64) = 0x29b05842637239e`,  
giving us `F = (hi << 64) + lo = 0x29b05842637239e0273d3d4255f6b19 = 3463373886635289660353622154000952089`

Heading over to [factorization](https://www.alpertron.com.ar/ECM.HTM), since this is a small number,
its factors are easily obtained as - `11, 13, 109, 223, 1290533, 4608287, 167541865434116759`.

Okay, having obtained the factors, we're now confused what to do!

Well, the best we can do is obtain all possible pairs of `(F1, F2)` by taking all the subsets of the set of factors.
But how do we know which are the correct ones? 

`S = s | 0xc000000000000001` to our rescue! We know that `F = (S * a^15)%(1 << 64)` or, `S = (F * z^15)%(1 << 64)`
as well as the fact that `S` has its first, second & last bits set, ie, `S & 0xc000000000000001` is indeed `0xc000000000000001`!

Thus, we could obtain `(S1,S2)` for any `(F1,F2)` and then check whether the above condition holds for both `S1` & `S2`, as well as the fact that the numbers generated from `S1` & `S2` must be prime!  
Luckily, we obtain only one such combination - `(F1,F2) = (1590130175551765067,2178044250643517867)`!

Thus, we have -
`S1 = 14567509746395306455 = 0xca2a30eeafeed9d7` & `S2 = 15648764542394866359 = 0xd92b9470cb2c9ab7`

Having obtained `S1` & `S2`, we can then generate the corresponding prime `p` & `q`, from where we can obtain `d = e^(-1) modulo (p-1)*(q-1)`, and then the message, which is `CTF{__donald_knuths_lcg_would_be_better_well_i_dont_think_s0__}`

```python
# solve.py

from functools import reduce
from itertools import chain, combinations
from operator import mul
import gmpy2
from Crypto.Util.number import *

n = 0xab802dca026b18251449baece42ba2162bf1f8f5dda60da5f8baef3e5dd49d155c1701a21c2bd5dfee142fd3a240f429878c8d4402f5c4c7f4bc630c74a4d263db3674669a18c9a7f5018c2f32cb4732acf448c95de86fcd6f312287cebff378125f12458932722ca2f1a891f319ec672da65ea03d0e74e7b601a04435598e2994423362ec605ef5968456970cb367f6b6e55f9d713d82f89aca0b633e7643ddb0ec263dc29f0946cfc28ccbf8e65c2da1b67b18a3fbc8cee3305a25841dfa31990f9aab219c85a2149e51dff2ab7e0989a50d988ca9ccdce34892eb27686fa985f96061620e6902e42bdd00d2768b14a9eb39b3feee51e80273d3d4255f6b19
e = 0x10001
c = 0x6a12d56e26e460f456102c83c68b5cf355b2e57d5b176b32658d07619ce8e542d927bbea12fb8f90d7a1922fe68077af0f3794bfd26e7d560031c7c9238198685ad9ef1ac1966da39936b33c7bb00bdb13bec27b23f87028e99fdea0fbee4df721fd487d491e9d3087e986a79106f9d6f5431522270200c5d545d19df446dee6baa3051be6332ad7e4e6f44260b1594ec8a588c0450bcc8f23abb0121bcabf7551fd0ec11cd61c55ea89ae5d9bcc91f46b39d84f808562a42bb87a8854373b234e71fe6688021672c271c22aad0887304f7dd2b5f77136271a571591c48f438e6f1c08ed65d0088da562e0d8ae2dadd1234e72a40141429f5746d2d41452d916

a = 0xe64a5f84e2762be5
chunk_size = 64

z = gmpy2.invert(a, 1 << 64)
v = pow(z, 15, 1 << 64)


def check(x):
    if (x < (1 << 64)):
        q = (x * v) % (1 << 64)
        if (q & 0xc000000000000001 == 0xc000000000000001) and (gen_prime(q) is not None):
            return True


def sanitize(l):
    z = []
    for p, q in l:
        if (check(p) is not None) and (check(q) is not None):
            if (p > q):
                p, q = q, p
            z.append((p, q))
    return z


def gen_prime(s):
    s |= 0xc000000000000001
    p = 0
    for _ in range(1024 // chunk_size):
        p = (p << chunk_size) + s
        s = a * s % 2**chunk_size
    if gmpy2.is_prime(p):
        return p


M = n % (1 << 64)
N = (n // (1 << 64)) % (1 << 64)
lo = M
hi = (N-2*z*lo) % (1 << 64)

F = (hi << 64)+lo
print(F)
# factors
fac = [11, 13, 109, 223, 1290533, 4608287, 167541865434116759]

t = [reduce(mul, x, 1) for x in (chain.from_iterable(combinations(fac, r)
                                                     for r in range((len(fac)) + 1)))]
t = [(i, int(F)//i) for i in t]
print(set(sanitize(t)))
# {(1590130175551765067, 2178044250643517867)}
S_1 = (1590130175551765067 * v) % (1 << 64)
S_2 = (2178044250643517867 * v) % (1 << 64)

p = gen_prime(S_1)
q = gen_prime(S_2)

assert(p*q == n)
print(long_to_bytes(pow(c, int(gmpy2.invert(e, (p-1)*(q-1))), n)))
```